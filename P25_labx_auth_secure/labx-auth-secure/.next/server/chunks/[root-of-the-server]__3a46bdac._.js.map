{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///D:/fast_api/fastAPI_learning/P25_labx_auth_secure/labx-auth-secure/lib/mongodb.ts"],"sourcesContent":["// \\labx-auth-secure\\lib\\mongodb.ts\r\n// This file gives your app a single, reusable connection to your MongoDB database\r\n\r\nimport { MongoClient } from \"mongodb\";\r\nconst uri = process.env.MONGODB_URI;\r\nconst options = {\r\n  maxPoolSize: 10,                  // Limits no of concurrent connections\r\n  serverSelectionTimeoutMS: 5000, // Timeout if MongoDB is unreachable (5s)\r\n  socketTimeoutMS: 10000,         // Timeout if no response from server\r\n  retryWrites: true              // Retry certain write operations\r\n};\r\n\r\n\r\nif (!uri) {\r\n  throw new Error(\"MONGODB_URI not found in environment variables. Add it to .env.local.\");\r\n}\r\n\r\n// Declare a reusable MongoClient instance and a connection status flag\r\n// client stores the MongoDB client instance.\r\nlet client: MongoClient;\r\n// clientPromise is a promise that resolves once the connection is open.\r\nlet clientPromise: Promise<MongoClient>;\r\n// isConnected is a custom flag used for health checks\r\nlet isConnected = false; \r\n\r\n// Connection strategy (Development/Prod)\r\n// In development, hot reloading can re-run this file multiple times, which can reset the status variable.\r\n// So we use a global variable (global._mongoClientPromise) to store the connection status.\r\n\r\nif (process.env.NODE_ENV === \"development\") {\r\n  // Connect to MongoDB once and cache the promise globally.\r\n  if (!(global as any)._mongoClientPromise) {\r\n    client = new MongoClient(uri, options);\r\n    (global as any)._mongoClientPromise = client.connect()\r\n      .then((connectedClient) => {\r\n        isConnected = true;\r\n        console.log(\"MongoDB connected (development)\");\r\n        return connectedClient;\r\n      })\r\n      .catch((err) => {\r\n        console.error(\"MongoDB connection failed (development):\", err);\r\n        throw err;\r\n      });\r\n  }\r\n  clientPromise = (global as any)._mongoClientPromise;\r\n} else {\r\n  client = new MongoClient(uri, options);\r\n  clientPromise = client.connect()\r\n    .then((connectedClient) => {\r\n      isConnected = true;\r\n      console.log(\"MongoDB connected (production)\");\r\n      return connectedClient;\r\n    })\r\n    .catch((err) => {\r\n      console.error(\"MongoDB connection failed (production):\", err);\r\n      throw err;\r\n    });\r\n}\r\n\r\n// promise that resolves to the connected MongoDB client\r\nexport default clientPromise;\r\n// for health checks\r\nexport { isConnected };\r\n"],"names":[],"mappings":"AAAA,mCAAmC;AACnC,kFAAkF;;;;;AAElF;;AACA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,MAAM,UAAU;IACd,aAAa;IACb,0BAA0B;IAC1B,iBAAiB;IACjB,aAAa,KAAkB,iCAAiC;AAClE;AAGA,IAAI,CAAC,KAAK;IACR,MAAM,IAAI,MAAM;AAClB;AAEA,uEAAuE;AACvE,6CAA6C;AAC7C,IAAI;AACJ,wEAAwE;AACxE,IAAI;AACJ,sDAAsD;AACtD,IAAI,cAAc;AAElB,yCAAyC;AACzC,0GAA0G;AAC1G,2FAA2F;AAE3F,wCAA4C;IAC1C,0DAA0D;IAC1D,IAAI,CAAC,AAAC,OAAe,mBAAmB,EAAE;QACxC,SAAS,IAAI,uGAAA,CAAA,cAAW,CAAC,KAAK;QAC7B,OAAe,mBAAmB,GAAG,OAAO,OAAO,GACjD,IAAI,CAAC,CAAC;YACL,cAAc;YACd,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT,GACC,KAAK,CAAC,CAAC;YACN,QAAQ,KAAK,CAAC,4CAA4C;YAC1D,MAAM;QACR;IACJ;IACA,gBAAgB,AAAC,OAAe,mBAAmB;AACrD,OAAO;;AAYP;uCAGe","debugId":null}},
    {"offset": {"line": 201, "column": 0}, "map": {"version":3,"sources":["file:///D:/fast_api/fastAPI_learning/P25_labx_auth_secure/labx-auth-secure/lib/authOptions.ts"],"sourcesContent":["// \\labx-auth-secure\\lib\\authOptions.ts\r\n\r\n// This file sets up login using username and password.\r\n// It checks the database for the user, verifies the password, and then gives the user a session token.\r\n// That token includes extra info like their role and what they can access.\r\n// Sessions and users are saved in MongoDB using a NextAuth adapter.\r\n\r\nimport type { AuthOptions } from \"next-auth\";\r\nimport CredentialsProvider from \"next-auth/providers/credentials\";\r\nimport { MongoDBAdapter } from \"@auth/mongodb-adapter\";\r\nimport clientPromise from \"./mongodb\";\r\nimport bcrypt from \"bcryptjs\";\r\n\r\n// format expect for access control on entities \r\nexport type EntityAccess = {\r\n  name: string;\r\n  read: boolean;\r\n  write: boolean;\r\n};\r\n\r\n// entity_access data is in the right format\r\nfunction normalizeEntityAccess(data: any): EntityAccess[] {\r\n  if (!Array.isArray(data)) return [];\r\n\r\n  return data.map((entry) => {\r\n    // If the entry is string, read-only access\r\n    if (typeof entry === \"string\") {\r\n      return { name: entry, read: true, write: false };\r\n    }\r\n    return {\r\n      name: entry.name ?? \"Unknown\",\r\n      read: entry.read ?? false,\r\n      write: entry.write ?? false,\r\n    };\r\n  });\r\n}\r\n\r\n// NextAuth setup\r\nexport const authOptions: AuthOptions = {\r\n  // Save user sessions and account info in MongoDB\r\n  adapter: MongoDBAdapter(clientPromise),\r\n\r\n  // Set up login using username/pswd \r\n  providers: [\r\n    CredentialsProvider({\r\n      name: \"Credentials\", // name appears on the sign-in page\r\n\r\n      // Fields shown on the signin login form\r\n      credentials: {\r\n        username: { label: \"Username\", type: \"text\", placeholder: \"Enter your username\" },\r\n        password: { label: \"Password\", type: \"password\", placeholder: \"Enter your password\" }\r\n      },\r\n\r\n      // runs when someone submits the login form\r\n      async authorize(credentials) {\r\n        // Validate presence of credentials\r\n        if (!credentials?.username || !credentials?.password) {\r\n          throw new Error(\"Missing username or password\");\r\n        }\r\n\r\n        const client = await clientPromise;\r\n        const db = client.db(process.env.DB_NAME);\r\n\r\n        // Find user by username\r\n        const user = await db.collection(\"users\").findOne({ username: credentials.username });\r\n\r\n        console.log(\"Login attempt for:\", credentials.username);\r\n        console.log(\"User found in DB:\", user);\r\n\r\n        // Validate user exists and has a password\r\n        if (!user || !user.password) {\r\n          throw new Error(\"User not found or missing password\");\r\n        }\r\n\r\n        // Validate password matches\r\n        const isValid = await bcrypt.compare(credentials.password, user.password);\r\n        if (!isValid) throw new Error(\"Invalid password\");\r\n\r\n        // Return minimal user object to be stored in token\r\n        return {\r\n          id: user._id.toString(),\r\n          name: user.username,\r\n          email: user.email,\r\n          role: user.role,\r\n          entity_access: user.entity_access,\r\n        };\r\n      }\r\n\r\n    })\r\n  ],\r\n\r\n  // Tell NextAuth to use JWT to store sessions\r\n  session: {\r\n    strategy: \"jwt\"\r\n  },\r\n\r\n  // add custom data into the session and token\r\n  callbacks: {\r\n    // runs when a token is created (after login)\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        token.role = user.role;\r\n        token.entity_access = normalizeEntityAccess(user.entity_access);\r\n      }\r\n      return token;\r\n    },\r\n\r\n    // runs every time the session is loaded \r\n    async session({ session, token }) {\r\n      if (session.user) {\r\n        session.user.role = token.role as string;\r\n        session.user.entity_access = token.entity_access as EntityAccess[];\r\n      }\r\n      return session;\r\n    }\r\n  },\r\n\r\n  // user needs to log in, send them to this page\r\n  // pages: {\r\n  //   signIn: \"/signin\"\r\n  // },\r\n  secret: process.env.NEXTAUTH_SECRET\r\n};\r\n"],"names":[],"mappings":"AAAA,uCAAuC;AAEvC,uDAAuD;AACvD,uGAAuG;AACvG,2EAA2E;AAC3E,oEAAoE;;;;AAGpE;AACA;AACA;AACA;;;;;AASA,4CAA4C;AAC5C,SAAS,sBAAsB,IAAS;IACtC,IAAI,CAAC,MAAM,OAAO,CAAC,OAAO,OAAO,EAAE;IAEnC,OAAO,KAAK,GAAG,CAAC,CAAC;QACf,2CAA2C;QAC3C,IAAI,OAAO,UAAU,UAAU;YAC7B,OAAO;gBAAE,MAAM;gBAAO,MAAM;gBAAM,OAAO;YAAM;QACjD;QACA,OAAO;YACL,MAAM,MAAM,IAAI,IAAI;YACpB,MAAM,MAAM,IAAI,IAAI;YACpB,OAAO,MAAM,KAAK,IAAI;QACxB;IACF;AACF;AAGO,MAAM,cAA2B;IACtC,iDAAiD;IACjD,SAAS,CAAA,GAAA,uJAAA,CAAA,iBAAc,AAAD,EAAE,gHAAA,CAAA,UAAa;IAErC,oCAAoC;IACpC,WAAW;QACT,CAAA,GAAA,0JAAA,CAAA,UAAmB,AAAD,EAAE;YAClB,MAAM;YAEN,wCAAwC;YACxC,aAAa;gBACX,UAAU;oBAAE,OAAO;oBAAY,MAAM;oBAAQ,aAAa;gBAAsB;gBAChF,UAAU;oBAAE,OAAO;oBAAY,MAAM;oBAAY,aAAa;gBAAsB;YACtF;YAEA,2CAA2C;YAC3C,MAAM,WAAU,WAAW;gBACzB,mCAAmC;gBACnC,IAAI,CAAC,aAAa,YAAY,CAAC,aAAa,UAAU;oBACpD,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,SAAS,MAAM,gHAAA,CAAA,UAAa;gBAClC,MAAM,KAAK,OAAO,EAAE,CAAC,QAAQ,GAAG,CAAC,OAAO;gBAExC,wBAAwB;gBACxB,MAAM,OAAO,MAAM,GAAG,UAAU,CAAC,SAAS,OAAO,CAAC;oBAAE,UAAU,YAAY,QAAQ;gBAAC;gBAEnF,QAAQ,GAAG,CAAC,sBAAsB,YAAY,QAAQ;gBACtD,QAAQ,GAAG,CAAC,qBAAqB;gBAEjC,0CAA0C;gBAC1C,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;oBAC3B,MAAM,IAAI,MAAM;gBAClB;gBAEA,4BAA4B;gBAC5B,MAAM,UAAU,MAAM,mIAAA,CAAA,UAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;gBACxE,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;gBAE9B,mDAAmD;gBACnD,OAAO;oBACL,IAAI,KAAK,GAAG,CAAC,QAAQ;oBACrB,MAAM,KAAK,QAAQ;oBACnB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,eAAe,KAAK,aAAa;gBACnC;YACF;QAEF;KACD;IAED,6CAA6C;IAC7C,SAAS;QACP,UAAU;IACZ;IAEA,6CAA6C;IAC7C,WAAW;QACT,6CAA6C;QAC7C,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,IAAI,GAAG,KAAK,IAAI;gBACtB,MAAM,aAAa,GAAG,sBAAsB,KAAK,aAAa;YAChE;YACA,OAAO;QACT;QAEA,yCAAyC;QACzC,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;gBAC9B,QAAQ,IAAI,CAAC,aAAa,GAAG,MAAM,aAAa;YAClD;YACA,OAAO;QACT;IACF;IAEA,+CAA+C;IAC/C,WAAW;IACX,sBAAsB;IACtB,KAAK;IACL,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC","debugId":null}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///D:/fast_api/fastAPI_learning/P25_labx_auth_secure/labx-auth-secure/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["// app/api/auth/[...nextauth]/route.ts\r\n\r\n// We're telling NextAuth to use our setup (authOptions) to creating a handler\r\n// This handler will now take care of: Logging in users, Checking if someone is logged in, Logging out, Token generation\r\n\r\n// Next.js API routes can handle HTTP methods like GET and POST.\r\n// If someone sends a GET request to /api/auth, use this handler. For checking session status, Loading the sign-in form\r\n// If someone sends a POST request to /api/auth, also use this handler. For submitting login credentials, Logging out\r\n\r\nimport NextAuth from \"next-auth\";\r\nimport { authOptions } from \"@/lib/authOptions\";\r\n\r\nconst handler = NextAuth(authOptions);\r\n\r\nexport { handler as GET, handler as POST };\r\n"],"names":[],"mappings":"AAAA,sCAAsC;AAEtC,8EAA8E;AAC9E,wHAAwH;AAExH,gEAAgE;AAChE,uHAAuH;AACvH,qHAAqH;;;;;AAErH;AACA;;;AAEA,MAAM,UAAU,CAAA,GAAA,uIAAA,CAAA,UAAQ,AAAD,EAAE,oHAAA,CAAA,cAAW","debugId":null}}]
}